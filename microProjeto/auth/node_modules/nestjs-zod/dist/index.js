'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var common = require('@nestjs/common');
var z = require('@nest-zod/z');
var deepmerge = require('deepmerge');
var rxjs = require('rxjs');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var deepmerge__default = /*#__PURE__*/_interopDefaultLegacy(deepmerge);

function createZodDto(schema) {
  class AugmentedZodDto {
    static create(input) {
      return this.schema.parse(input);
    }
  }
  AugmentedZodDto.isZodDto = true;
  AugmentedZodDto.schema = schema;
  return AugmentedZodDto;
}
function isZodDto(metatype) {
  return metatype == null ? void 0 : metatype.isZodDto;
}

class ZodValidationException extends common.BadRequestException {
  constructor(error) {
    super({
      statusCode: common.HttpStatus.BAD_REQUEST,
      message: "Validation failed",
      errors: error.errors
    });
    this.error = error;
  }
  getZodError() {
    return this.error;
  }
}
class ZodSerializationException extends common.InternalServerErrorException {
  constructor(error) {
    super();
    this.error = error;
  }
  getZodError() {
    return this.error;
  }
}
const createZodValidationException = (error) => {
  return new ZodValidationException(error);
};
const createZodSerializationException = (error) => {
  return new ZodSerializationException(error);
};

function validate(value, schemaOrDto, createValidationException = createZodValidationException) {
  const schema = isZodDto(schemaOrDto) ? schemaOrDto.schema : schemaOrDto;
  const result = schema.safeParse(value);
  if (!result.success) {
    throw createValidationException(result.error);
  }
  return result.data;
}

var __defProp$2 = Object.defineProperty;
var __getOwnPropDesc$2 = Object.getOwnPropertyDescriptor;
var __decorateClass$2 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$2(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$2(target, key, result);
  return result;
};
function createZodGuard({
  createValidationException
} = {}) {
  let ZodGuard2 = class {
    constructor(source, schemaOrDto) {
      this.source = source;
      this.schemaOrDto = schemaOrDto;
    }
    canActivate(context) {
      const data = context.switchToHttp().getRequest()[this.source];
      validate(data, this.schemaOrDto, createValidationException);
      return true;
    }
  };
  ZodGuard2 = __decorateClass$2([
    common.Injectable()
  ], ZodGuard2);
  return ZodGuard2;
}
const ZodGuard = createZodGuard();
const UseZodGuard = (source, schemaOrDto) => common.UseGuards(new ZodGuard(source, schemaOrDto));

function is(input, factory) {
  const factories = z.z;
  return factory === factories[input._def.typeName];
}
function zodToOpenAPI(zodType, visited = /* @__PURE__ */ new Set()) {
  const object = {};
  if (zodType.description) {
    object.description = zodType.description;
  }
  if (is(zodType, z.z.ZodString)) {
    const { checks } = zodType._def;
    object.type = "string";
    for (const check of checks) {
      if (check.kind === "min") {
        object.minLength = check.value;
      } else if (check.kind === "max") {
        object.maxLength = check.value;
      } else if (check.kind === "email") {
        object.format = "email";
      } else if (check.kind === "url") {
        object.format = "uri";
      } else if (check.kind === "uuid") {
        object.format = "uuid";
      } else if (check.kind === "cuid") {
        object.format = "cuid";
      } else if (check.kind === "regex") {
        object.pattern = check.regex.source;
      } else if (check.kind === "datetime") {
        object.format = "date-time";
      }
    }
  }
  if (is(zodType, z.z.ZodPassword)) {
    const { checks } = zodType._def;
    const regex = zodType.buildFullRegExp();
    object.type = "string";
    object.format = "password";
    object.pattern = regex.source;
    for (const check of checks) {
      if (check.kind === "minLength") {
        object.minLength = check.value;
      } else if (check.kind === "maxLength") {
        object.maxLength = check.value;
      }
    }
  }
  if (is(zodType, z.z.ZodBoolean)) {
    object.type = "boolean";
  }
  if (is(zodType, z.z.ZodNumber)) {
    const { checks } = zodType._def;
    object.type = "number";
    for (const check of checks) {
      if (check.kind === "int") {
        object.type = "integer";
      } else if (check.kind === "min") {
        object.minimum = check.value;
        object.exclusiveMinimum = !check.inclusive;
      } else if (check.kind === "max") {
        object.maximum = check.value;
        object.exclusiveMaximum = !check.inclusive;
      } else if (check.kind === "multipleOf") {
        object.multipleOf = check.value;
      }
    }
  }
  if (is(zodType, z.z.ZodDateString)) {
    const { checks } = zodType._def;
    object.type = "string";
    for (const check of checks) {
      if (check.kind === "format") {
        object.format = check.value;
      }
    }
  }
  if (is(zodType, z.z.ZodBigInt)) {
    object.type = "integer";
    object.format = "int64";
  }
  if (is(zodType, z.z.ZodArray)) {
    const { minLength, maxLength, type } = zodType._def;
    object.type = "array";
    if (minLength)
      object.minItems = minLength.value;
    if (maxLength)
      object.maxItems = maxLength.value;
    object.items = zodToOpenAPI(type, visited);
  }
  if (is(zodType, z.z.ZodTuple)) {
    const { items } = zodType._def;
    object.type = "array";
    object.items = { oneOf: items.map((item) => zodToOpenAPI(item, visited)) };
  }
  if (is(zodType, z.z.ZodSet)) {
    const { valueType, minSize, maxSize } = zodType._def;
    object.type = "array";
    if (minSize)
      object.minItems = minSize.value;
    if (maxSize)
      object.maxItems = maxSize.value;
    object.items = zodToOpenAPI(valueType, visited);
    object.uniqueItems = true;
  }
  if (is(zodType, z.z.ZodUnion)) {
    const { options } = zodType._def;
    object.oneOf = options.map((option) => zodToOpenAPI(option, visited));
  }
  if (is(zodType, z.z.ZodDiscriminatedUnion)) {
    const { options } = zodType._def;
    object.oneOf = [];
    for (const schema of options.values()) {
      object.oneOf.push(zodToOpenAPI(schema, visited));
    }
  }
  if (is(zodType, z.z.ZodLiteral)) {
    const { value } = zodType._def;
    if (typeof value === "string") {
      object.type = "string";
      object.enum = [value];
    }
    if (typeof value === "number") {
      object.type = "number";
      object.minimum = value;
      object.maximum = value;
    }
    if (typeof value === "boolean") {
      object.type = "boolean";
    }
  }
  if (is(zodType, z.z.ZodEnum)) {
    const { values } = zodType._def;
    object.type = "string";
    object.enum = values;
  }
  if (is(zodType, z.z.ZodNativeEnum)) {
    const { values } = zodType._def;
    object.type = "string";
    object.enum = Object.values(values);
    object["x-enumNames"] = Object.keys(values);
  }
  if (is(zodType, z.z.ZodTransformer)) {
    const { schema } = zodType._def;
    Object.assign(object, zodToOpenAPI(schema, visited));
  }
  if (is(zodType, z.z.ZodNullable)) {
    const { innerType } = zodType._def;
    Object.assign(object, zodToOpenAPI(innerType, visited));
    object.nullable = true;
  }
  if (is(zodType, z.z.ZodOptional)) {
    const { innerType } = zodType._def;
    Object.assign(object, zodToOpenAPI(innerType, visited));
  }
  if (is(zodType, z.z.ZodDefault)) {
    const { defaultValue, innerType } = zodType._def;
    Object.assign(object, zodToOpenAPI(innerType, visited));
    object.default = defaultValue();
  }
  if (is(zodType, z.z.ZodObject)) {
    const { shape } = zodType._def;
    object.type = "object";
    object.properties = {};
    object.required = [];
    for (const [key, schema] of Object.entries(shape())) {
      object.properties[key] = zodToOpenAPI(schema, visited);
      const optionalTypes = [z.z.ZodOptional.name, z.z.ZodDefault.name];
      const isOptional = optionalTypes.includes(schema.constructor.name);
      if (!isOptional)
        object.required.push(key);
    }
    if (object.required.length === 0) {
      delete object.required;
    }
  }
  if (is(zodType, z.z.ZodRecord)) {
    const { valueType } = zodType._def;
    object.type = "object";
    object.additionalProperties = zodToOpenAPI(valueType, visited);
  }
  if (is(zodType, z.z.ZodIntersection)) {
    const { left, right } = zodType._def;
    const merged = deepmerge__default["default"](
      zodToOpenAPI(left, visited),
      zodToOpenAPI(right, visited),
      {
        arrayMerge: (target, source) => {
          const mergedSet = /* @__PURE__ */ new Set([...target, ...source]);
          return Array.from(mergedSet);
        }
      }
    );
    Object.assign(object, merged);
  }
  if (is(zodType, z.z.ZodEffects)) {
    const { schema } = zodType._def;
    Object.assign(object, zodToOpenAPI(schema, visited));
  }
  if (is(zodType, z.z.ZodLazy)) {
    const { getter } = zodType._def;
    if (visited.has(getter))
      return object;
    visited.add(getter);
    Object.assign(object, zodToOpenAPI(getter(), visited));
  }
  return object;
}

function getSchemaObjectFactory() {
  return require("@nestjs/swagger/dist/services/schema-object-factory").SchemaObjectFactory;
}
function patchNestJsSwagger(SchemaObjectFactory = getSchemaObjectFactory()) {
  if (SchemaObjectFactory.prototype.__patchedWithLoveByNestjsZod)
    return;
  const defaultExplore = SchemaObjectFactory.prototype.exploreModelSchema;
  const extendedExplore = function exploreModelSchema(type, schemas, schemaRefsStack) {
    if (this && this["isLazyTypeFunc"](type)) {
      const factory = type;
      type = factory();
    }
    if (!isZodDto(type)) {
      return defaultExplore.call(this, type, schemas, schemaRefsStack);
    }
    schemas[type.name] = zodToOpenAPI(type.schema);
    return type.name;
  };
  SchemaObjectFactory.prototype.exploreModelSchema = extendedExplore;
  SchemaObjectFactory.prototype.__patchedWithLoveByNestjsZod = true;
}

var __defProp$1 = Object.defineProperty;
var __getOwnPropDesc$1 = Object.getOwnPropertyDescriptor;
var __decorateClass$1 = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc$1(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp$1(target, key, result);
  return result;
};
function createZodValidationPipe({
  createValidationException
} = {}) {
  let ZodValidationPipe2 = class {
    constructor(schemaOrDto) {
      this.schemaOrDto = schemaOrDto;
    }
    transform(value, metadata) {
      if (this.schemaOrDto) {
        return validate(value, this.schemaOrDto, createValidationException);
      }
      const { metatype } = metadata;
      if (!isZodDto(metatype)) {
        return value;
      }
      return validate(value, metatype.schema, createValidationException);
    }
  };
  ZodValidationPipe2 = __decorateClass$1([
    common.Injectable()
  ], ZodValidationPipe2);
  return ZodValidationPipe2;
}
const ZodValidationPipe = createZodValidationPipe();

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var __decorateParam = (index, decorator) => (target, key) => decorator(target, key, index);
const REFLECTOR = "Reflector";
const ZodSerializerDtoOptions = "ZOD_SERIALIZER_DTO_OPTIONS";
const ZodSerializerDto = (dto) => common.SetMetadata(ZodSerializerDtoOptions, dto);
exports.ZodSerializerInterceptor = class {
  constructor(reflector) {
    this.reflector = reflector;
  }
  intercept(context, next) {
    const responseSchema = this.getContextResponseSchema(context);
    return next.handle().pipe(
      rxjs.map((res) => {
        if (!responseSchema)
          return res;
        if (typeof res !== "object" || res instanceof common.StreamableFile)
          return res;
        return Array.isArray(res) ? res.map(
          (item) => validate(item, responseSchema, createZodSerializationException)
        ) : validate(res, responseSchema, createZodSerializationException);
      })
    );
  }
  getContextResponseSchema(context) {
    return this.reflector.getAllAndOverride(ZodSerializerDtoOptions, [
      context.getHandler(),
      context.getClass()
    ]);
  }
};
exports.ZodSerializerInterceptor = __decorateClass([
  common.Injectable(),
  __decorateParam(0, common.Inject(REFLECTOR))
], exports.ZodSerializerInterceptor);

exports.UseZodGuard = UseZodGuard;
exports.ZodGuard = ZodGuard;
exports.ZodSerializationException = ZodSerializationException;
exports.ZodSerializerDto = ZodSerializerDto;
exports.ZodValidationException = ZodValidationException;
exports.ZodValidationPipe = ZodValidationPipe;
exports.createZodDto = createZodDto;
exports.createZodGuard = createZodGuard;
exports.createZodValidationPipe = createZodValidationPipe;
exports.patchNestJsSwagger = patchNestJsSwagger;
exports.validate = validate;
exports.zodToOpenAPI = zodToOpenAPI;
