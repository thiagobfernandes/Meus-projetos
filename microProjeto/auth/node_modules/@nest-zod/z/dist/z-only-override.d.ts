import * as zod from 'zod';
import { ZodIssueBase, ZodIssueCode, ZodIssueOptionalMessage, ParseContext, ZodErrorMap, ZodTypeDef, ZodSchema, z, ZodType, ParseInput, ParseReturnType } from 'zod';
export * from 'zod';

type DateStringFormat = 'date' | 'date-time';
type DateStringDirection = 'past' | 'future';
type DateStringDayType = 'weekDay' | 'weekend';
interface ZodInvalidDateStringIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params: {
        isNestJsZod: true;
        code: 'invalid_date_string';
    };
}
interface ZodInvalidDateStringFormatIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params: {
        isNestJsZod: true;
        code: 'invalid_date_string_format';
        expected: DateStringFormat;
    };
}
interface ZodInvalidDateStringDirectionIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params: {
        isNestJsZod: true;
        code: 'invalid_date_string_direction';
        expected: DateStringDirection;
    };
}
interface ZodInvalidDateStringDayIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params: {
        isNestJsZod: true;
        code: 'invalid_date_string_day';
        expected: DateStringDayType;
    };
}
type ZodAnyDateStringIssue = ZodInvalidDateStringIssue | ZodInvalidDateStringFormatIssue | ZodInvalidDateStringDirectionIssue | ZodInvalidDateStringDayIssue;

type ZodMinMaxValueType = 'array' | 'string' | 'number' | 'bigint' | 'set' | 'date_string_year' | 'date' | 'password';
interface ZodTooSmallIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_small;
    minimum: number | bigint;
    inclusive: boolean;
    type: ZodMinMaxValueType;
}
interface ZodTooBigIssue extends ZodIssueBase {
    code: typeof ZodIssueCode.too_big;
    maximum: number | bigint;
    inclusive: boolean;
    type: ZodMinMaxValueType;
}

interface ZodInvalidPasswordNoDigit extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params: {
        isNestJsZod: true;
        code: 'invalid_password_no_digit';
    };
}
interface ZodInvalidPasswordNoLowercase extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params: {
        isNestJsZod: true;
        code: 'invalid_password_no_lowercase';
    };
}
interface ZodInvalidPasswordNoUppercase extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params: {
        isNestJsZod: true;
        code: 'invalid_password_no_uppercase';
    };
}
interface ZodInvalidPasswordNoSpecial extends ZodIssueBase {
    code: typeof ZodIssueCode.custom;
    params: {
        isNestJsZod: true;
        code: 'invalid_password_no_special';
    };
}
type ZodAnyPasswordIssue = ZodInvalidPasswordNoDigit | ZodInvalidPasswordNoLowercase | ZodInvalidPasswordNoUppercase | ZodInvalidPasswordNoSpecial;

declare type StripPath<T extends object> = T extends any ? Omit<T, 'path'> : never;
type NestJsZodIssue = ZodAnyDateStringIssue | ZodAnyPasswordIssue;
type ZodIssueOptionalMessageExtended = ZodIssueOptionalMessage | NestJsZodIssue | ZodTooSmallIssue | ZodTooBigIssue;
type ZodIssueExtended = ZodIssueOptionalMessageExtended & {
    message: string;
};
type IssueDataExtended = StripPath<ZodIssueOptionalMessageExtended> & {
    path?: (string | number)[];
    fatal?: boolean;
};
declare function addIssueToContextExtended(context: ParseContext, issueData: IssueDataExtended): void;

type ErrorMapContext = Parameters<ZodErrorMap>[1];
type ZodErrorMapExtended = (issue: ZodIssueOptionalMessageExtended, context: ErrorMapContext) => ReturnType<ZodErrorMap>;
declare const extendedErrorMap: ZodErrorMapExtended;
declare function setExtendedErrorMap(map: ZodErrorMapExtended): void;

declare function from<TOutput = any, TDef extends ZodTypeDef = ZodTypeDef, TInput = TOutput>(schema: ZodSchema<TOutput, TDef, TInput>): ZodSchema<TOutput, TDef, TInput>;

type Literal = boolean | number | string;
type Json = Literal | {
    [key: string]: Json;
} | Json[];
declare const json: (message?: string) => z.ZodType<Json, z.ZodTypeDef, Json>;

type ErrorMessage = string | {
    message?: string;
};
interface RawCreateParams {
    errorMap?: ZodErrorMapExtended;
    invalid_type_error?: string;
    required_error?: string;
    description?: string;
}

declare enum ZodFirstPartyTypeKindExtended {
    ZodDateString = "ZodDateString",
    ZodPassword = "ZodPassword"
}

type ZodIsoDateCheck = {
    kind: 'format';
    value: DateStringFormat;
    regex: RegExp;
    message?: string;
} | {
    kind: 'direction';
    direction: DateStringDirection;
    message?: string;
} | {
    kind: 'day-type';
    type: DateStringDayType;
    message?: string;
} | {
    kind: 'minYear';
    value: number;
    message?: string;
} | {
    kind: 'maxYear';
    value: number;
    message?: string;
};
interface ZodDateStringDef extends ZodTypeDef {
    checks: ZodIsoDateCheck[];
    typeName: ZodFirstPartyTypeKindExtended.ZodDateString;
}
declare class ZodDateString extends ZodType<string, ZodDateStringDef> {
    _parse(input: ParseInput): ParseReturnType<string>;
    _replaceCheck(check: ZodIsoDateCheck): ZodDateString;
    static create: (params?: RawCreateParams) => ZodDateString;
    format(format: DateStringFormat, message?: ErrorMessage): ZodDateString;
    past(message?: ErrorMessage): ZodDateString;
    future(message?: ErrorMessage): ZodDateString;
    weekDay(message?: ErrorMessage): ZodDateString;
    weekend(message?: ErrorMessage): ZodDateString;
    minYear(year: number, message?: ErrorMessage): ZodDateString;
    maxYear(year: number, message?: ErrorMessage): ZodDateString;
    cast(): zod.ZodEffects<this, Date, zod.input<this>>;
    get format_(): ({
        kind: "format";
    } & {
        kind: "format";
        value: DateStringFormat;
        regex: RegExp;
        message?: string;
    }) | undefined;
    get isPast(): boolean;
    get isFuture(): boolean;
    get isWeekDay(): boolean;
    get isWeekend(): boolean;
    get minYear_(): ({
        kind: "minYear";
    } & {
        kind: "minYear";
        value: number;
        message?: string;
    }) | undefined;
    get maxYear_(): ({
        kind: "maxYear";
    } & {
        kind: "maxYear";
        value: number;
        message?: string;
    }) | undefined;
}
declare const dateString: (params?: RawCreateParams) => ZodDateString;

type SymbolKind = 'digit' | 'lowercase' | 'uppercase' | 'special';
interface ZodPasswordSymbolCheck {
    kind: SymbolKind;
    message?: string;
}
type ZodPasswordCheck = ZodPasswordSymbolCheck | {
    kind: 'minLength';
    value: number;
    message?: string;
} | {
    kind: 'maxLength';
    value: number;
    message?: string;
};
interface ZodPasswordDef extends ZodTypeDef {
    checks: ZodPasswordCheck[];
    typeName: ZodFirstPartyTypeKindExtended.ZodPassword;
}
declare class ZodPassword extends ZodType<string, ZodPasswordDef> {
    _parse(input: ParseInput): ParseReturnType<string>;
    _replaceCheck(check: ZodPasswordCheck): ZodPassword;
    static create: (params?: RawCreateParams) => ZodPassword;
    buildFullRegExp(): RegExp;
    atLeastOne(kind: SymbolKind, message?: ErrorMessage): ZodPassword;
    min(length: number, message?: ErrorMessage): ZodPassword;
    max(length: number, message?: ErrorMessage): ZodPassword;
    isAtLeastOne(kind: SymbolKind): boolean;
    get minLength(): ({
        kind: "minLength";
    } & {
        kind: "minLength";
        value: number;
        message?: string;
    }) | undefined;
    get maxLength(): ({
        kind: "maxLength";
    } & {
        kind: "maxLength";
        value: number;
        message?: string;
    }) | undefined;
}
declare const password: (params?: RawCreateParams) => ZodPassword;

export { Json, ZodDateString, ZodDateStringDef, ZodErrorMapExtended as ZodErrorMap, ZodFirstPartyTypeKindExtended, ZodInvalidDateStringDayIssue, ZodIssueExtended as ZodIssue, ZodIssueOptionalMessageExtended as ZodIssueOptionalMessage, ZodPassword, ZodPasswordDef, ZodTooBigIssue, ZodTooSmallIssue, addIssueToContextExtended as addIssueToContext, dateString, extendedErrorMap as defaultErrorMap, from, json, password, setExtendedErrorMap as setErrorMap };
